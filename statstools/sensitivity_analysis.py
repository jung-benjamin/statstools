#! /usr/bin/env python3


"""Functions for Sensitivity Analysis

Contains wrapper functions for the SALib library and functions
to assess the convergence of the sensitivity indices.
"""

import os as os
import numpy as np
import pandas as pd
from itertools import combinations
from SALib.analyze import sobol

def format_saltelli(Y: np.ndarray, num_ma: int, len_ma: int) -> np.ndarray:
    """Convert matrix format to saltelli format

    Reshapes the output array generated by the model to fit the required
    shape of the input for the sobol.analyze function of the SALib 
    module.
    Assumes the shape of the model output is (num_par + 2) x num_samples.

    Parameters
    ----------
    Y
        Vector of model output 
    num_ma
        Number of matrices (number of parameters + 2)
    len_ma
        Number of samples in one matrix

    Returns
    -------
    Y_saltelli
        Reshaped output vector 
    """
    Y_saltelli = np.roll(Y, len(Y) - 1, axis = 0)
    Y_saltelli = np.reshape(Y_saltelli, num_ma * len_ma, order = 'F')

    return Y_saltelli

def calc_sobol_indices(Y, problem, print_out=False, 
                       keep=False, resamples=1000, cast_negative=False):
    """Calculate Sobol sensitivity indices for model output
    
    Uses the SALib module to calculate the first-order and total sobol
    indices. Optionally, the bootstrap samples can be stored to compute 
    other statistics that require bootstrapping. Returns the sensitivity 
    indices as a pandas dataframe. Second-order indices cannot be computed 
    with the current format of the input array.
    
    Parameters
    ----------
    Y
        np.ndarray, array of model output with shape (num_par+2, num_samples)
    problem
        dict, problem dictionary as required by the SALib module
    print_out
        bool, optional, if True the sensitivity indices are printed to
        the console
    keep
        bool, optional, if True also returns the bootstrap samples
    resamples
        int, optional, change the number of resamples for bootstrapping
    
    Output
    ------
    si_df
        pandas dataframe of the computed indices with confidence intervals
    si_resamples
        optional, if keep is True a pandas dataframe of the bootstrap
        samples is also returned
    """
    D, N = Y.shape
    Y_format = format_saltelli(Y, D, N)
    Si = sobol.analyze(problem, Y_format, calc_second_order = False,
                       num_resamples = resamples,
                       print_to_console = print_out,
                       keep_resamples=keep,
                       )
    if not keep:
        si_df = pd.DataFrame.from_dict(Si).set_index([problem['names']])
        if cast_negative:
            si_df[si_df < 0] = 0
        return si_df
    else:
        si_names = ['S1', 'S1_conf', 'ST', 'ST_conf']
        si_dict = {key: Si[key] for key in si_names}
        si_df = pd.DataFrame.from_dict(si_dict).set_index([problem['names']])
        st_all = pd.DataFrame(Si['ST_conf_all'].T, index=problem['names'])
        s1_all = pd.DataFrame(Si['S1_conf_all'].T, index=problem['names'])
        si_resamples = pd.concat([s1_all, st_all], axis=1, keys=['S1', 'ST'])
        if cast_negative:
            si_df[si_df < 0] = 0
            si_resamples[si_resamples < 0] = 0
        return si_df, si_resamples
    
def summary_statistic(df, label):
    """Compute a summary statistic to check convergence
    
    The width of the 95% confidence interval is used as a 
    summary statistic to evaluate the convergence of the
    sensitivity index values.
    """
    width = df.loc[:, label] * 2
    stat = np.max(width)
    return stat

def screening_convergence(df, idx, idx_conf, threshold):
    """Calculate convergence of low impact indices"""
    low_impact = df.loc[df[idx] < threshold]
    stat = np.max(list(low_impact[idx_conf] * 2))
    
    return stat

def rank_index(data, by):
    """Rank parameters in dataframe by a column
    
    Sorts the parameter names of the dataframe by the 
    values of a specified column. Assigns values to 
    each parameter. Higher assigned value indicates 
    higher rank and higher importance.
    
    Parameters
    ----------
    data
        pd.dataframe, contains the sensitivity indices
        parameters are listed in the rows and different 
        indices in the columns
    by
        str, name of a column containing the sensitivity
        index by which to rank the parameters
        if by == "all" iterate over all columns of the 
        dataframe and calculate rankings for each
        
    Output
    ------
    ranked
        pd.Series or pd.DataFrame of the rank of each parameter
    """
    if by == 'all':
        rank_list = []
        for n, it in data.items():
            sorted_col = it.sort_values()
            names = sorted_col.index
            ranks = np.arange(1, len(names) + 1)
            rank_series = pd.Series(ranks, index=names, name=n)
            rank_list.append(rank_series)
        ranked = pd.concat(rank_list, axis=1)
    else:
        df = data.sort_values(by=by)
        names = df.index
        ranks = np.arange(1, len(names) + 1)
        ranked = pd.Series(ranks, index=names, name=f'{by} rank')

    return ranked

def rank_correlation_coefficient(df1, df2, rank1, rank2):
    """Calculate the correlation of two parameter ranking
    
    The disagreement between the rankings of the two bootstrap
    samples of sensitivity indices is calculated and weighted 
    by the value of the respective indices.
    Parameters of higher significance have a higher weight in
    the ranking correlation
    
    Input parameters should all be pandas.Series with the
    index being the names of the parameters. This is important
    so that the ranks are associated correctly with the value
    of the corresponding sensitivity index.
    """
    max_si_sj = pd.concat([df1, df2], axis=1).max(axis=1)**2
    sum_max = max_si_sj.sum()
    rank_diff = np.abs(rank1 - rank2)
    rho = (rank_diff * max_si_sj / sum_max).sum()
    return rho

def ranking_statistic(data, ranks):
    """Calculate ranking statistic for sensitvity indices 
    
    The ranking statistic is the 95% quantile of the rank
    correllation coefficients of the bootstrap sample set.
    A value below 1 indicates the ranking has converged.
    """
    rho_sjk = []
    for i, j in combinations(data, 2):
        rho = rank_correlation_coefficient(data[i], data[j], ranks[i], ranks[j])
        rho_sjk.append(rho)
        
    Q95 = np.quantile(rho_sjk, 0.95)
    return Q95
